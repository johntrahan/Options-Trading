library(tidyverse)

# Define Monte Carlo Pricer class
MonteCarloPricer <- function(spot, strike, maturity, r, sigma, n_steps, n_paths, optionType) {
  
  # Class initialization
  self = list(
    strike = strike,
    spot = spot,
    sigma = sigma,
    r = r,
    maturity = maturity,
    n_paths = n_paths,
    n_steps = n_steps,
    optionType = optionType
  )
  
  # Method to generate the random paths
  self$generatePaths = function() {
    dt <- self$maturity / self$n_steps
    ito <- (self$r - self$sigma^2/2) * dt
    sqvar <- self$sigma * sqrt(dt)
    innovation <- matrix(rnorm(self$n_steps * self$n_paths), nrow = self$n_steps)
    paths <- matrix(self$spot, nrow = self$n_steps + 1, ncol = self$n_paths)
    for (i in 2:(self$n_steps + 1)) {
      paths[i,] <- paths[i-1,] * exp(ito + sqvar * innovation[i-1,])
    }
    paths <- paths[-1,]
    return(paths)
  }
  
  # Method to visualize the paths generated by the generatePaths method
  library(ggplot2)
  
  self$visualizePaths = function(paths) {
    df <- data.frame(paths)
    colnames(df) <- paste0("Path", 1:self$n_paths)
    df$TimeSteps <- 1:nrow(df)
    df <- tidyr::gather(df, key = "Path", value = "StockPrice", -TimeSteps)
    
    ggplot(df, aes(x = TimeSteps, y = StockPrice, color = Path)) +
      geom_line() +
      geom_hline(yintercept = self$strike) +
      ggtitle(paste0("Simulated stock prices with ", self$n_steps,
                     " steps and ", self$n_paths, " price paths\n",
                     self$optionType, " option with strike price of ", self$strike)) +
      xlab("Time Steps") +
      ylab("Stock Price")
  }

  # Payoff function depending on the contract type, call or put
  payoff <- function(paths) {
    n_steps <- nrow(paths)
    n_paths <- ncol(paths)
    
    # initialize payoff matrix
    payoffs <- matrix(0, nrow = n_steps, ncol = n_paths)
    
    # compute payoff at maturity
    if (self$optionType == "call") {
      payoffs[n_steps, ] <- pmax(paths[n_steps, ] - self$strike, 0)
    } else if (self$optionType == "put") {
      payoffs[n_steps, ] <- pmax(self$strike - paths[n_steps, ], 0)
    }
    
    # compute payoff at every time step and compare to intrinsic value of early exercise
    for (i in (n_steps - 1):1) {
      if (self$optionType == "call") {
        intrinsic_value <- pmax(paths[i, ] - self$strike, 0)
      } else if (self$optionType == "put") {
        intrinsic_value <- pmax(self$strike - paths[i, ], 0)
      }
      early_exercise <- intrinsic_value > payoffs[i+1, ]
      payoffs[i, early_exercise] <- intrinsic_value[early_exercise]
      payoffs[i, !early_exercise] <- payoffs[i+1, !early_exercise]
    }
    
    return(payoffs[1,])
  }
  
  
  # Method to discount the paths price
  discountedExpectation <- function(payoffs) {
    return(mean(payoffs) * exp(-self$r * self$maturity))
  }
  
  # Return list of methods
  return(list(generatePaths = self$generatePaths,
              visualizePaths = self$visualizePaths,
              payoff = payoff,
              discountedExpectation = discountedExpectation))
}

# Define input parameters
S <- 75.58   # Spot price
K <- 55   # Strike price
T <- 10/365   # Time to maturity in years
r <- 0.0352  # Risk-free rate
sigma <- 0.0176626*sqrt(252) # Volatility
steps <- 100 # Number of steps
N <- 100 # Number of paths
optionType <- "call" # Option contract type

# Initialize the Monte Carlo Pricer
pricer <- MonteCarloPricer(S, K, T, r, sigma, steps, N, optionType)

# Generate random paths and visualize them
paths <- pricer$generatePaths()
pricer$visualizePaths(paths)

# Calculate the discounted expectation of the option payoff
payoffs <- pricer$payoff(paths)
cat("Expected Payout is",pricer$discountedExpectation(payoffs))

#make sure to find volatility, either implied volatility or 
#use past year's daily change sd * sqrt(252)
#To avoid the first number from yahoo finance
#NEE = NEE %>%
#select(Date,Close) %>%
#mutate(daily_change = (Close - lag(Close))/lag(Close),
#percentage_change = (Close - lag(Close))/lag(Close)*100)

#NEE %>%
#filter(row_number() != 1) %>%
#summarize(mean = mean(daily_change),
#sd = sd(daily_change))